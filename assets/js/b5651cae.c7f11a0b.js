"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[1855],{3905:(e,t,n)=>{n.d(t,{Zo:()=>d,kt:()=>c});var a=n(7294);function l(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){l(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,l=function(e,t){if(null==e)return{};var n,a,l={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(l[n]=e[n]);return l}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(l[n]=e[n])}return l}var o=a.createContext({}),p=function(e){var t=a.useContext(o),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},d=function(e){var t=p(e.components);return a.createElement(o.Provider,{value:t},e.children)},u="mdxType",k={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var n=e.components,l=e.mdxType,i=e.originalType,o=e.parentName,d=s(e,["components","mdxType","originalType","parentName"]),u=p(n),m=l,c=u["".concat(o,".").concat(m)]||u[m]||k[m]||i;return n?a.createElement(c,r(r({ref:t},d),{},{components:n})):a.createElement(c,r({ref:t},d))}));function c(e,t){var n=arguments,l=t&&t.mdxType;if("string"==typeof e||l){var i=n.length,r=new Array(i);r[0]=m;var s={};for(var o in t)hasOwnProperty.call(t,o)&&(s[o]=t[o]);s.originalType=e,s[u]="string"==typeof e?e:l,r[1]=s;for(var p=2;p<i;p++)r[p]=n[p];return a.createElement.apply(null,r)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},3313:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>o,contentTitle:()=>r,default:()=>k,frontMatter:()=>i,metadata:()=>s,toc:()=>p});var a=n(7462),l=(n(7294),n(3905));n(8209);const i={id:"library",title:"Smart Contracts - Library",sidebar_label:"Library",sidebar_position:4},r=void 0,s={unversionedId:"build/smart-contracts/language/library",id:"build/smart-contracts/language/library",title:"Smart Contracts - Library",description:"The Smart Contract library is composed of many modules with many functions in each.",source:"@site/docs/build/smart-contracts/language/library.md",sourceDirName:"build/smart-contracts/language",slug:"/build/smart-contracts/language/library",permalink:"/build/smart-contracts/language/library",draft:!1,tags:[],version:"current",lastUpdatedAt:1694426346,formattedLastUpdatedAt:"Sep 11, 2023",sidebarPosition:4,frontMatter:{id:"library",title:"Smart Contracts - Library",sidebar_label:"Library",sidebar_position:4},sidebar:"docs",previous:{title:"Actions",permalink:"/build/smart-contracts/language/actions"},next:{title:"Examples",permalink:"/build/smart-contracts/language/examples"}},o={},p=[{value:"String",id:"string",level:2},{value:"size/1",id:"size1",level:3},{value:"in?/2",id:"in2",level:3},{value:"to_number/1",id:"to_number1",level:3},{value:"from_number/1",id:"from_number1",level:3},{value:"to_hex/1",id:"to_hex1",level:3},{value:"to_uppercase/1",id:"to_uppercase1",level:3},{value:"to_lowercase/1",id:"to_lowercase1",level:3},{value:"Map",id:"map",level:2},{value:"new/0",id:"new0",level:3},{value:"size/1",id:"size1-1",level:3},{value:"get/2",id:"get2",level:3},{value:"get/3",id:"get3",level:3},{value:"set/3",id:"set3",level:3},{value:"keys/1",id:"keys1",level:3},{value:"values/1",id:"values1",level:3},{value:"delete/2",id:"delete2",level:3},{value:"List",id:"list",level:2},{value:"at/2",id:"at2",level:3},{value:"size/1",id:"size1-2",level:3},{value:"in?/2",id:"in2-1",level:3},{value:"empty?/1",id:"empty1",level:3},{value:"concat/2",id:"concat2",level:3},{value:"append/2",id:"append2",level:3},{value:"prepend/2",id:"prepend2",level:3},{value:"join/2",id:"join2",level:3},{value:"Regex",id:"regex",level:2},{value:"extract/2",id:"extract2",level:3},{value:"match?/2",id:"match2",level:3},{value:"scan/2",id:"scan2",level:3},{value:"Json",id:"json",level:2},{value:"path_extract/2",id:"path_extract2",level:3},{value:"path_match?/2",id:"path_match2",level:3},{value:"to_string/1",id:"to_string1",level:3},{value:"parse/1",id:"parse1",level:3},{value:"is_valid?/1",id:"is_valid1",level:3},{value:"Time",id:"time",level:2},{value:"now/0",id:"now0",level:3},{value:"Chain",id:"chain",level:2},{value:"get_genesis_address/1 <code>[I/O]</code>",id:"get_genesis_address1-io",level:3},{value:"get_first_transaction_address/1 <code>[I/O]</code>",id:"get_first_transaction_address1-io",level:3},{value:"get_genesis_public_key/1 <code>[I/O]</code>",id:"get_genesis_public_key1-io",level:3},{value:"get_burn_address/0",id:"get_burn_address0",level:3},{value:"get_transaction/1  <code>[I/O]</code>",id:"get_transaction1--io",level:3},{value:"Crypto",id:"crypto",level:2},{value:"hash/1",id:"hash1",level:3},{value:"hash/2",id:"hash2",level:3},{value:"Token",id:"token",level:2},{value:"fetch_id_from_address/1 <code>[I/O]</code>",id:"fetch_id_from_address1-io",level:3},{value:"Code",id:"code",level:2},{value:"is_same?/2",id:"is_same2",level:3},{value:"is_valid?/1",id:"is_valid1-1",level:3},{value:"Http",id:"http",level:2},{value:"fetch/1 <code>[I/O]</code>",id:"fetch1-io",level:3},{value:"fetch_many/1 <code>[I/O]</code>",id:"fetch_many1-io",level:3},{value:"Contract",id:"contract",level:2},{value:"call_function/3 <code>[I/O]</code>",id:"call_function3-io",level:3},{value:"set_type/1 <code>[Transaction]</code>",id:"set_type1-transaction",level:3},{value:"set_content/1 <code>[Transaction]</code>",id:"set_content1-transaction",level:3},{value:"set_code/1 <code>[Transaction]</code>",id:"set_code1-transaction",level:3},{value:"add_uco_transfer/1 <code>[Transaction]</code>",id:"add_uco_transfer1-transaction",level:3},{value:"add_uco_transfers/1 <code>[Transaction]</code>",id:"add_uco_transfers1-transaction",level:3},{value:"add_token_transfer/1 <code>[Transaction]</code>",id:"add_token_transfer1-transaction",level:3},{value:"add_token_transfers/1 <code>[Transaction]</code>",id:"add_token_transfers1-transaction",level:3},{value:"add_ownership/1 <code>[Transaction]</code>",id:"add_ownership1-transaction",level:3},{value:"add_ownerships/1 <code>[Transaction]</code>",id:"add_ownerships1-transaction",level:3},{value:"add_recipient/1 <code>[Transaction]</code>",id:"add_recipient1-transaction",level:3},{value:"add_recipients/1 <code>[Transaction]</code>",id:"add_recipients1-transaction",level:3}],d={toc:p},u="wrapper";function k(e){let{components:t,...n}=e;return(0,l.kt)(u,(0,a.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,l.kt)("p",null,"The Smart Contract library is composed of many modules with many functions in each.\n",(0,l.kt)("strong",{parentName:"p"},"Unless it is explicitely written, the functions will not mutate their arguments"),":"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-elixir"},"# Don't\nsold_items = [1,2,3]\nList.concat(sold_items, [4,5,6])\n\n# Do\nsold_items = [1,2,3]\nsold_items = List.concat(sold_items, [4,5,6])\n")),(0,l.kt)("admonition",{title:"function/arity",type:"note"},(0,l.kt)("p",{parentName:"admonition"},"In this page, the number after the slash indicates the arity of the function (number or arguments)."),(0,l.kt)("p",{parentName:"admonition"},"For example ",(0,l.kt)("inlineCode",{parentName:"p"},"size/1")," means the function ",(0,l.kt)("inlineCode",{parentName:"p"},"size")," has 1 argument.")),(0,l.kt)("admonition",{title:"Tagged functions",type:"info"},(0,l.kt)("p",{parentName:"admonition"},"Functions are tagged as ",(0,l.kt)("inlineCode",{parentName:"p"},"[Transaction]")," are special:"),(0,l.kt)("ul",{parentName:"admonition"},(0,l.kt)("li",{parentName:"ul"},"They are only available in the ",(0,l.kt)("inlineCode",{parentName:"li"},"actions")," block."),(0,l.kt)("li",{parentName:"ul"},'They mutate an internal state, the "next transaction".'),(0,l.kt)("li",{parentName:"ul"},'This "next transaction" is initiated with current contract (all values but transfers are copied)')),(0,l.kt)("p",{parentName:"admonition"},"Other functions are tagged as ",(0,l.kt)("inlineCode",{parentName:"p"},"[I/O]")," and help to fetch data making network calls by either:"),(0,l.kt)("ul",{parentName:"admonition"},(0,l.kt)("li",{parentName:"ul"},"requesting Archethic"),(0,l.kt)("li",{parentName:"ul"},"requesting the outside world"))),(0,l.kt)("h2",{id:"string"},"String"),(0,l.kt)("h3",{id:"size1"},"size/1"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-elixir"},'String.size("hello")   # 5\nString.size("\u4f60\u597d")     # 2\n')),(0,l.kt)("p",null,"Parameters:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"str")," the string")),(0,l.kt)("p",null,"Returns the number of characters in ",(0,l.kt)("inlineCode",{parentName:"p"},"str"),"."),(0,l.kt)("h3",{id:"in2"},"in?/2"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-elixir"},'String.in?("bob,alice,julia", "alice")  # true\nString.in?("bob,alice,julia", "fred")   # false\n')),(0,l.kt)("p",null,"Parameters:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"str1")," the haystack"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"str2")," the needle")),(0,l.kt)("p",null,"Returns whether the ",(0,l.kt)("inlineCode",{parentName:"p"},"needle")," is in the ",(0,l.kt)("inlineCode",{parentName:"p"},"haystack"),"."),(0,l.kt)("h3",{id:"to_number1"},"to_number/1"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-elixir"},'String.to_number("12")     # 12\nString.to_number("-12")    # -12\nString.to_number("12.1")   # 12.1\n')),(0,l.kt)("p",null,"Parameters:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"str")," the string")),(0,l.kt)("p",null,"Returns the number which text representation is ",(0,l.kt)("inlineCode",{parentName:"p"},"str"),"."),(0,l.kt)("h3",{id:"from_number1"},"from_number/1"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-elixir"},'String.from_number(13)     # "13"\nString.from_number(13.2)   # "13.2"\n')),(0,l.kt)("p",null,"Parameters:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"number")," the number")),(0,l.kt)("p",null,"Returns the text representation of ",(0,l.kt)("inlineCode",{parentName:"p"},"number"),"."),(0,l.kt)("h3",{id:"to_hex1"},"to_hex/1"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-elixir"},'String.to_hex("592ac76afa") # "592AC76AFA"\nString.to_hex("592AC76AFA") # "592AC76AFA"\nString.to_hex("hello") # "68656C6C6F"\n')),(0,l.kt)("p",null,"Parameters:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"str")," the string")),(0,l.kt)("p",null,"Return the text representation of hexadecimal ",(0,l.kt)("inlineCode",{parentName:"p"},"str"),".\nIf ",(0,l.kt)("inlineCode",{parentName:"p"},"str")," is already an hex it just uppercase it"),(0,l.kt)("h3",{id:"to_uppercase1"},"to_uppercase/1"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-elixir"},'String.to_uppercase("Ars\xe8ne Lupin") # "ARS\xc8NE LUPIN"\n')),(0,l.kt)("p",null,"Parameters:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"str")," the string")),(0,l.kt)("p",null,"Return the ",(0,l.kt)("inlineCode",{parentName:"p"},"str")," in uppercase."),(0,l.kt)("h3",{id:"to_lowercase1"},"to_lowercase/1"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-elixir"},'String.to_lowercase("Sherlock Holmes") # "sherlock holmes"\n')),(0,l.kt)("p",null,"Parameters:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"str")," the string")),(0,l.kt)("p",null,"Return the ",(0,l.kt)("inlineCode",{parentName:"p"},"str")," in lowercase."),(0,l.kt)("hr",null),(0,l.kt)("h2",{id:"map"},"Map"),(0,l.kt)("h3",{id:"new0"},"new/0"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-elixir"},"Map.new() # empty map\n")),(0,l.kt)("p",null,"Returns an empty map. There is no shorthand notation."),(0,l.kt)("h3",{id:"size1-1"},"size/1"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-elixir"},'Map.size(key1: "value", key2: "value2") # 2\n')),(0,l.kt)("p",null,"Parameters:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"map")," the map")),(0,l.kt)("p",null,"Returns the number of keys in ",(0,l.kt)("inlineCode",{parentName:"p"},"map"),"."),(0,l.kt)("h3",{id:"get2"},"get/2"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-elixir"},'Map.get([key1: "value", key2: "value2"], "key1") # "value"\nMap.get([key1: "value", key2: "value2"], "key3") # nil\n')),(0,l.kt)("p",null,"Parameters:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"map")," the map"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"key")," the key")),(0,l.kt)("p",null,"Returns the value at ",(0,l.kt)("inlineCode",{parentName:"p"},"key")," in ",(0,l.kt)("inlineCode",{parentName:"p"},"map")," or ",(0,l.kt)("inlineCode",{parentName:"p"},"nil")," if ",(0,l.kt)("inlineCode",{parentName:"p"},"key")," is not in the ",(0,l.kt)("inlineCode",{parentName:"p"},"map"),"."),(0,l.kt)("admonition",{type:"tip"},(0,l.kt)("p",{parentName:"admonition"},"There is a shorthand notation ",(0,l.kt)("inlineCode",{parentName:"p"},"map.key")," when key is not a variable.")),(0,l.kt)("h3",{id:"get3"},"get/3"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-elixir"},'Map.get([key1: "value", key2: "value2"], "key1", "not in map") # "value"\nMap.get([key1: "value", key2: "value2"], "key3", "not in map") # "not in map"\n')),(0,l.kt)("p",null,"Parameters:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"map")," the map"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"key")," the key"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"default")," the default value")),(0,l.kt)("p",null,"Returns the value at ",(0,l.kt)("inlineCode",{parentName:"p"},"key")," in ",(0,l.kt)("inlineCode",{parentName:"p"},"map")," or ",(0,l.kt)("inlineCode",{parentName:"p"},"default")," if ",(0,l.kt)("inlineCode",{parentName:"p"},"key")," is not in the ",(0,l.kt)("inlineCode",{parentName:"p"},"map"),"."),(0,l.kt)("h3",{id:"set3"},"set/3"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-elixir"},'Map.set([key1: "value", key2: "value2"], "key1", "valueX") # [key1: "valueX", key2: "value2"]\nMap.get([key1: "value", key2: "value2"], "key3", "value3") # [key1: "value", key2: "value2, key3: "value3"]\n')),(0,l.kt)("p",null,"Parameters:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"map")," the map"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"key")," the key"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"value")," the value to set")),(0,l.kt)("p",null,"Returns a copy of ",(0,l.kt)("inlineCode",{parentName:"p"},"map")," where the value at ",(0,l.kt)("inlineCode",{parentName:"p"},"key")," is ",(0,l.kt)("inlineCode",{parentName:"p"},"value"),"."),(0,l.kt)("h3",{id:"keys1"},"keys/1"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-elixir"},'Map.keys(key1: "value", key2: "value2") # ["key1", "key2"]\n')),(0,l.kt)("p",null,"Parameters:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"map")," the map")),(0,l.kt)("p",null,"Returns the list of keys in ",(0,l.kt)("inlineCode",{parentName:"p"},"map"),"."),(0,l.kt)("admonition",{type:"tip"},(0,l.kt)("p",{parentName:"admonition"},"Use it with a ",(0,l.kt)("inlineCode",{parentName:"p"},"for loop")," to iterate on a map!"),(0,l.kt)("pre",{parentName:"admonition"},(0,l.kt)("code",{parentName:"pre"},"for key in Map.keys(map) do\n    ...\n    value = map[key]\n    ...\nend\n"))),(0,l.kt)("h3",{id:"values1"},"values/1"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-elixir"},'Map.values(key1: "value", key2: "value2") # ["value", "value2"]\n')),(0,l.kt)("p",null,"Parameters:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"map")," the map")),(0,l.kt)("p",null,"Returns the list of values in ",(0,l.kt)("inlineCode",{parentName:"p"},"map"),"."),(0,l.kt)("h3",{id:"delete2"},"delete/2"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-elixir"},'Map.delete([key1: "value", key2: "value2"], "key2") # [key1: "value"]\n')),(0,l.kt)("p",null,"Parameters:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"map")," the map"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"key")," the key to remove")),(0,l.kt)("p",null,"Returns a copy of the ",(0,l.kt)("inlineCode",{parentName:"p"},"map")," without the value at given ",(0,l.kt)("inlineCode",{parentName:"p"},"key"),"."),(0,l.kt)("hr",null),(0,l.kt)("h2",{id:"list"},"List"),(0,l.kt)("p",null,"Lists are actually ",(0,l.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Linked_list"},"Linked List"),"."),(0,l.kt)("h3",{id:"at2"},"at/2"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-elixir"},'List.at(["a", "b", "c"], 0)     # "a"\nList.at(["a", "b", "c"], 1)     # "b"\nList.at(["a", "b", "c"], 2)     # "c"\nList.at([], 0)                  # nil\n')),(0,l.kt)("p",null,"Parameters:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"list")," the list"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"index")," the index (zero-based)")),(0,l.kt)("p",null,"Returns the element at ",(0,l.kt)("inlineCode",{parentName:"p"},"index")," in ",(0,l.kt)("inlineCode",{parentName:"p"},"list"),"."),(0,l.kt)("h3",{id:"size1-2"},"size/1"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-elixir"},"List.size([])           # 0\nList.size([1,2,3,4])    # 4\n")),(0,l.kt)("p",null,"Parameters:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"list")," the list")),(0,l.kt)("p",null,"Returns the number of keys in ",(0,l.kt)("inlineCode",{parentName:"p"},"list"),"."),(0,l.kt)("h3",{id:"in2-1"},"in?/2"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-elixir"},'List.in?(["bob", "alice"], "alice") # true\nList.in?(["bob", "alice"], "fred")  # false\n')),(0,l.kt)("p",null,"Parameters:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"list")," the haystack"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"element")," the needle")),(0,l.kt)("p",null,"Returns whether the ",(0,l.kt)("inlineCode",{parentName:"p"},"needle")," is in the ",(0,l.kt)("inlineCode",{parentName:"p"},"haystack"),"."),(0,l.kt)("h3",{id:"empty1"},"empty?/1"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-elixir"},'List.empty?([])         # true\nList.empty?(["apple"])  # false\n')),(0,l.kt)("p",null,"Parameters:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"list")," the list")),(0,l.kt)("p",null,"Returns whether the ",(0,l.kt)("inlineCode",{parentName:"p"},"list")," is empty or not."),(0,l.kt)("h3",{id:"concat2"},"concat/2"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-elixir"},"List.concat([], [])         # []\nList.concat([1,2], [3,4])   # [1,2,3,4]\n")),(0,l.kt)("p",null,"Parameters:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"list1")," a list"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"list2")," another list")),(0,l.kt)("p",null,"Returns a new list where ",(0,l.kt)("inlineCode",{parentName:"p"},"list2")," is concatenated to ",(0,l.kt)("inlineCode",{parentName:"p"},"list1"),"."),(0,l.kt)("h3",{id:"append2"},"append/2"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-elixir"},"List.append([], 1)    # [1]\nList.append([1], 2)   # [1,2]\n")),(0,l.kt)("p",null,"Parameters:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"list")," the list"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"element")," the element")),(0,l.kt)("p",null,"Returns a new list where ",(0,l.kt)("inlineCode",{parentName:"p"},"element")," is appended to the end of ",(0,l.kt)("inlineCode",{parentName:"p"},"list"),"."),(0,l.kt)("admonition",{type:"tip"},(0,l.kt)("p",{parentName:"admonition"},"If order doesn't matter, we suggest to use ",(0,l.kt)("inlineCode",{parentName:"p"},"prepend/2")," instead (Complexity: O(1) instead of O(n)).")),(0,l.kt)("h3",{id:"prepend2"},"prepend/2"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-elixir"},"List.prepend([], 1)    # [1]\nList.prepend([1], 0)   # [0,1]\n")),(0,l.kt)("p",null,"Parameters:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"list")," the list"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"element")," the element")),(0,l.kt)("p",null,"Returns a new list where ",(0,l.kt)("inlineCode",{parentName:"p"},"element")," is appended to the start of ",(0,l.kt)("inlineCode",{parentName:"p"},"list"),"."),(0,l.kt)("h3",{id:"join2"},"join/2"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-elixir"},'List.join([], ", ")    # ""\nList.join(["Mike", "Robert", "Joe"], ", ")   # "Mike, Robert, Joe"\n')),(0,l.kt)("p",null,"Parameters:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"list")," the list of strings"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"separator")," the separator")),(0,l.kt)("p",null,"Returns a string where all ",(0,l.kt)("inlineCode",{parentName:"p"},"list"),"'s elements have been joined with ",(0,l.kt)("inlineCode",{parentName:"p"},"separator")," separator."),(0,l.kt)("hr",null),(0,l.kt)("h2",{id:"regex"},"Regex"),(0,l.kt)("h3",{id:"extract2"},"extract/2"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-elixir"},'Regex.extract("123456abc", "[0-9]+")    # "123456"\nRegex.extract("voodoo", "[abc]")        # ""\n')),(0,l.kt)("p",null,"Parameters:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"text")," the list"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"pattern")," the element")),(0,l.kt)("p",null,"Returns the data from ",(0,l.kt)("inlineCode",{parentName:"p"},"text")," extract via the regex ",(0,l.kt)("inlineCode",{parentName:"p"},"pattern"),"."),(0,l.kt)("h3",{id:"match2"},"match?/2"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-elixir"},'Regex.match?("123456", "^[0-9]+$")      # true\nRegex.match?("123456abc", "^[0-9]+$")   # false\n')),(0,l.kt)("p",null,"Parameters:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"text")," the list"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"pattern")," the element")),(0,l.kt)("p",null,"Returns whether the ",(0,l.kt)("inlineCode",{parentName:"p"},"pattern")," matches the ",(0,l.kt)("inlineCode",{parentName:"p"},"text")," or not."),(0,l.kt)("h3",{id:"scan2"},"scan/2"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-elixir"},'Regex.scan("foo", "bar")                                    # []\nRegex.scan("toto,123\\ntutu,456\\n", "toto,([0-9]+)")         # ["123"]\nRegex.scan("toto,123\\ntutu,456\\n", "t.t.,([0-9]+)")         # ["123", "456"]\nRegex.scan("A0B1C2,123\\nD3E4F5,456\\n", "^(\\\\w+),(\\\\d+)$")   # [["A0B1C2", "123"], ["D3E4F5", "456"]]\n\n')),(0,l.kt)("p",null,"Parameters:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"text")," the list"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"pattern")," the element")),(0,l.kt)("p",null,"Returns the data from ",(0,l.kt)("inlineCode",{parentName:"p"},"text")," extract via the regex ",(0,l.kt)("inlineCode",{parentName:"p"},"pattern"),"."),(0,l.kt)("admonition",{type:"note"},(0,l.kt)("p",{parentName:"admonition"},"This function requires the usage of capture groups (subexpressions).")),(0,l.kt)("hr",null),(0,l.kt)("h2",{id:"json"},"Json"),(0,l.kt)("p",null,"Functions to manipulate JSON strings."),(0,l.kt)("p",null,"Useful resources:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("a",{parentName:"li",href:"https://goessner.net/articles/JsonPath/"},"JSONPath documentation"))),(0,l.kt)("h3",{id:"path_extract2"},"path_extract/2"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-elixir"},'Json.path_extract("{ \\"firstName\\": \\"John\\", \\"lastName\\": \\"Doe\\"}", "$.firstName") # "John"\n')),(0,l.kt)("p",null,"Parameters:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"json")," the json string"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"path")," the path")),(0,l.kt)("p",null,"Returns the data at ",(0,l.kt)("inlineCode",{parentName:"p"},"path")," in ",(0,l.kt)("inlineCode",{parentName:"p"},"json"),"."),(0,l.kt)("h3",{id:"path_match2"},"path_match?/2"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-elixir"},'Json.path_match?("{\\"1622541930\\":{\\"uco\\":{\\"eur\\":0.176922,\\"usd\\":0.21642}}}", "$.*.uco.usd") # true\nJson.path_match?("{\\"1622541930\\":{\\"uco\\":{\\"eur\\":0.176922,\\"usd\\":0.21642}}}", "$.*.uco.aud") # false\n')),(0,l.kt)("p",null,"Parameters:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"json")," the json string"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"path")," the path")),(0,l.kt)("p",null,"Returns if there is a value at ",(0,l.kt)("inlineCode",{parentName:"p"},"path")," in ",(0,l.kt)("inlineCode",{parentName:"p"},"json"),"."),(0,l.kt)("h3",{id:"to_string1"},"to_string/1"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-elixir"},'Json.to_string(1)           # "1"\nJson.to_string("str")       # "\\"str\\""\nJson.to_string([1,2,3])     # "[1,2,3]"\nJson.to_string(foo: "bar")  # "{\\"foo\\":\\"bar\\"}"\n')),(0,l.kt)("p",null,"Parameters:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"any")," anything")),(0,l.kt)("p",null,"Returns the Json representation of ",(0,l.kt)("inlineCode",{parentName:"p"},"any"),"."),(0,l.kt)("h3",{id:"parse1"},"parse/1"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-elixir"},'Json.parse("1")                     # "1"\nJson.parse("\\"str\\"")               # "str"\nJson.parse("[1,2,3]")               # [1,2,3]\nJson.parse("{\\"foo\\":\\"bar\\"}")     # foo: "bar"\n')),(0,l.kt)("p",null,"Parameters:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"json")," the json string")),(0,l.kt)("p",null,"Returns the value represented by ",(0,l.kt)("inlineCode",{parentName:"p"},"json"),"."),(0,l.kt)("h3",{id:"is_valid1"},"is_valid?/1"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-elixir"},'Json.is_valid?("str")        # false\nJson.is_valid?("\\"str\\"")    # true\n')),(0,l.kt)("p",null,"Parameters:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"json")," the json string")),(0,l.kt)("p",null,"Returns whether the string is valid JSON or not."),(0,l.kt)("hr",null),(0,l.kt)("h2",{id:"time"},"Time"),(0,l.kt)("h3",{id:"now0"},"now/0"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-elixir"},"Time.now()  # 1677493444\n")),(0,l.kt)("p",null,"Returns an approximation of current time (seconds since epoch).\n",(0,l.kt)("strong",{parentName:"p"},"It will always return the same value within a contract.")),(0,l.kt)("admonition",{title:"Why an approximation?",type:"info"},(0,l.kt)("p",{parentName:"admonition"},"Because we need the smart contracts to be determinist.\nMany nodes will run them and all of them must produce the same transaction to validate a contract's execution.")),(0,l.kt)("hr",null),(0,l.kt)("h2",{id:"chain"},"Chain"),(0,l.kt)("h3",{id:"get_genesis_address1-io"},"get_genesis_address/1 ",(0,l.kt)("inlineCode",{parentName:"h3"},"[I/O]")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-elixir"},'Chain.get_genesis_address("000012345...") # "000056789..."\nChain.get_genesis_address("000012345...") # "000012345..."\n')),(0,l.kt)("p",null,"Parameters:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"address")," the transaction address")),(0,l.kt)("p",null,"Returns the genesis address of the transaction chain that contains a transaction at ",(0,l.kt)("inlineCode",{parentName:"p"},"address"),". If there is no transaction at ",(0,l.kt)("inlineCode",{parentName:"p"},"address"),", it returns ",(0,l.kt)("inlineCode",{parentName:"p"},"address"),"."),(0,l.kt)("h3",{id:"get_first_transaction_address1-io"},"get_first_transaction_address/1 ",(0,l.kt)("inlineCode",{parentName:"h3"},"[I/O]")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-elixir"},'Chain.get_first_transaction_address("000012345...") # "000056789..."\n')),(0,l.kt)("p",null,"Parameters:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"address")," the transaction address")),(0,l.kt)("p",null,"Returns the address of the first transaction of the transaction chain that contains a transaction at ",(0,l.kt)("inlineCode",{parentName:"p"},"address"),"."),(0,l.kt)("admonition",{type:"danger"},(0,l.kt)("p",{parentName:"admonition"},"[IT CURRENTLY CRASH IF THERE IS NO TRANSACTION]")),(0,l.kt)("h3",{id:"get_genesis_public_key1-io"},"get_genesis_public_key/1 ",(0,l.kt)("inlineCode",{parentName:"h3"},"[I/O]")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-elixir"},'Chain.get_genesis_public_key("00013B08D...") # "000108A5C..."\n')),(0,l.kt)("p",null,"Parameters:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"public_key")," the public key")),(0,l.kt)("p",null,"Returns the genesis public key of ",(0,l.kt)("inlineCode",{parentName:"p"},"public_key"),"."),(0,l.kt)("h3",{id:"get_burn_address0"},"get_burn_address/0"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-elixir"},'Chain.get_burn_address() # "0000000000..."\n')),(0,l.kt)("p",null,"Returns the burn address"),(0,l.kt)("h3",{id:"get_transaction1--io"},"get_transaction/1  ",(0,l.kt)("inlineCode",{parentName:"h3"},"[I/O]")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-elixir"},'Chain.get_transaction(0x00ABCD..) # [address: "00ABCD..", content: "...", uco_transfers: [], ...]\n')),(0,l.kt)("p",null,"Parameters:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"address")," the transaction address")),(0,l.kt)("p",null,"Returns the transaction at ",(0,l.kt)("inlineCode",{parentName:"p"},"address"),". If there is no transaction at ",(0,l.kt)("inlineCode",{parentName:"p"},"address"),", it returns ",(0,l.kt)("inlineCode",{parentName:"p"},"nil"),". See ",(0,l.kt)("a",{parentName:"p",href:"#appendix-1-the-transaction-map"},"Appendix 1"),"."),(0,l.kt)("hr",null),(0,l.kt)("h2",{id:"crypto"},"Crypto"),(0,l.kt)("h3",{id:"hash1"},"hash/1"),(0,l.kt)("p",null,"Equivalent to ",(0,l.kt)("a",{parentName:"p",href:"#hash2"},"hash/2"),' with the second argument "sha256".'),(0,l.kt)("h3",{id:"hash2"},"hash/2"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-elixir"},'Crypto.hash("my text", "sha256") # "7330D2B39CA35EA..."\nCrypto.hash("my text", "sha512") # "A3D7E45A0D9BE5F..."\n')),(0,l.kt)("p",null,"Parameters:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"str")," the text to hash"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"algo"),' the hash algorithm ("sha256", "sha512", "sha3_256", "sha3_512", "blake2b", "keccak256")')),(0,l.kt)("p",null,"Returns the hash of ",(0,l.kt)("inlineCode",{parentName:"p"},"str")," by using ",(0,l.kt)("inlineCode",{parentName:"p"},"algo")," algorithm."),(0,l.kt)("hr",null),(0,l.kt)("h2",{id:"token"},"Token"),(0,l.kt)("h3",{id:"fetch_id_from_address1-io"},"fetch_id_from_address/1 ",(0,l.kt)("inlineCode",{parentName:"h3"},"[I/O]")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-elixir"},'Token.fetch_id_from_address("000012345") # "3C21EF708BF11B4232..."\n')),(0,l.kt)("p",null,"Parameters:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"address")," the token address")),(0,l.kt)("p",null,"Returns the token's id of the token at ",(0,l.kt)("inlineCode",{parentName:"p"},"address"),"."),(0,l.kt)("hr",null),(0,l.kt)("h2",{id:"code"},"Code"),(0,l.kt)("h3",{id:"is_same2"},"is_same?/2"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-elixir"},'code = """\n@version\n\ncondition triggered_by: transaction, as: []\n\nactions triggered_by: transaction do\n  Contract.add_uco_transfer to: 0x1234, amount: 15.5\nend\n"""\n\nCode.is_same?(code, transaction.code)\n')),(0,l.kt)("p",null,"Parameters:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"first_code")," a string containing a smart contract code"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"second_code")," a string containing a smart contract code")),(0,l.kt)("p",null,"Return true if codes are the same, false otherwise.\nThis function is more accurate than comparing two strings, as it convert code into structured AST and compare only code instruction and not line numbers, carriage return ..."),(0,l.kt)("h3",{id:"is_valid1-1"},"is_valid?/1"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-elixir"},'code = """\n@version\n\ncondition triggered_by: transaction, as: []\n\nactions triggered_by: transaction do\n  Contract.add_uco_transfer to: 0x1234, amount: 15.5\nend\n"""\n\nCode.is_valid?(code)\n')),(0,l.kt)("p",null,"Parameters:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"code")," a string containing a smart contract code")),(0,l.kt)("p",null,"Returns true if the code is valid according to Archethic smart contracts language, false otherwise"),(0,l.kt)("hr",null),(0,l.kt)("h2",{id:"http"},"Http"),(0,l.kt)("h3",{id:"fetch1-io"},"fetch/1 ",(0,l.kt)("inlineCode",{parentName:"h3"},"[I/O]")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-elixir"},'response = Http.fetch("https://fakerapi.it/api/v1/addresses?_quantity=1&_seed=watermelon") # [status: 200, body: "..."]\nif response.status == 200 do\n    # do something with response.body\nend\n')),(0,l.kt)("p",null,"Parameters:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"url")," the url to fetch")),(0,l.kt)("p",null,"Fetch the given url (with a ",(0,l.kt)("inlineCode",{parentName:"p"},"GET"),") and returns a map with ",(0,l.kt)("inlineCode",{parentName:"p"},"status")," (integer) and ",(0,l.kt)("inlineCode",{parentName:"p"},"body")," (string).\nThis status integer can be any ",(0,l.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/HTTP/Status"},"HTTP status code"),"."),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"The URL must use HTTPS protocol."),(0,l.kt)("li",{parentName:"ul"},"The response body's size must be less than 256KB."),(0,l.kt)("li",{parentName:"ul"},"The response must be received in less than 2 seconds."),(0,l.kt)("li",{parentName:"ul"},"The response must be idempotent (= identical every time it is called)"),(0,l.kt)("li",{parentName:"ul"},"Only 1 call of either ",(0,l.kt)("inlineCode",{parentName:"li"},"fetch/1")," or ",(0,l.kt)("inlineCode",{parentName:"li"},"fetch_many/1")," is allowed per execution.")),(0,l.kt)("admonition",{type:"caution"},(0,l.kt)("p",{parentName:"admonition"},"The function raises if these requirements are not meet.")),(0,l.kt)("h3",{id:"fetch_many1-io"},"fetch_many/1 ",(0,l.kt)("inlineCode",{parentName:"h3"},"[I/O]")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-elixir"},'responses = Http.fetch_many([\n    "https://fakerapi.it/api/v1/users?_quantity=1&_gender=male&_seed=cucumber",\n    "https://fakerapi.it/api/v1/users?_quantity=1&_gender=female&_seed=tomato"\n])\nfor r in responses do\n    if r.status == 200 do\n        # do something with r.body\n    end\nend\n')),(0,l.kt)("p",null,"Parameters:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"urls")," a list of urls to fetch")),(0,l.kt)("p",null,"Fetch the given urls ",(0,l.kt)("strong",{parentName:"p"},"in parallel")," and returns a list of map with ",(0,l.kt)("inlineCode",{parentName:"p"},"status")," (integer) and ",(0,l.kt)("inlineCode",{parentName:"p"},"body")," (string). Order and length is preserved.\nThis status integer can be any ",(0,l.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/HTTP/Status"},"HTTP status code"),"."),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"The URLs must use HTTPS protocol."),(0,l.kt)("li",{parentName:"ul"},"The sum of response bodies' size must not be bigger than 256KB."),(0,l.kt)("li",{parentName:"ul"},"The responses must be received in less than 2 seconds."),(0,l.kt)("li",{parentName:"ul"},"The responses must be idempotent (= identical every time it is called)"),(0,l.kt)("li",{parentName:"ul"},"Only 1 call of either ",(0,l.kt)("inlineCode",{parentName:"li"},"fetch/1")," or ",(0,l.kt)("inlineCode",{parentName:"li"},"fetch_many/1")," is allowed per execution."),(0,l.kt)("li",{parentName:"ul"},"The URLs are limited to 5.")),(0,l.kt)("admonition",{type:"caution"},(0,l.kt)("p",{parentName:"admonition"},"The function raises if these requirements are not meet.")),(0,l.kt)("hr",null),(0,l.kt)("h2",{id:"contract"},"Contract"),(0,l.kt)("h3",{id:"call_function3-io"},"call_function/3 ",(0,l.kt)("inlineCode",{parentName:"h3"},"[I/O]")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-elixir"},'Contract.call_function(0x0000ABCD..., "add", [1, 2])\n')),(0,l.kt)("p",null,"Parameters:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"contract_address")," the contract's adddress"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"function_name")," the function name"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"args")," the list of arguments to call the function with")),(0,l.kt)("p",null,"Calls the exported function ",(0,l.kt)("inlineCode",{parentName:"p"},"function_name")," of the Smart Contract at ",(0,l.kt)("inlineCode",{parentName:"p"},"contract_address")," with given ",(0,l.kt)("inlineCode",{parentName:"p"},"args")," and return the result value."),(0,l.kt)("h3",{id:"set_type1-transaction"},"set_type/1 ",(0,l.kt)("inlineCode",{parentName:"h3"},"[Transaction]")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-elixir"},'Contract.set_type("transfer")\n')),(0,l.kt)("p",null,"Parameters:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"type"),' the transaction type ("contract", "transfer", "data", "hosting")')),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Mutates")," the next transaction to be of type ",(0,l.kt)("inlineCode",{parentName:"p"},"type"),"."),(0,l.kt)("h3",{id:"set_content1-transaction"},"set_content/1 ",(0,l.kt)("inlineCode",{parentName:"h3"},"[Transaction]")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-elixir"},'Contract.set_content("Hello Smart Contract")\n')),(0,l.kt)("p",null,"Parameters:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"content")," the transaction's content (we usually use this as the state of the smart contract)")),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Mutates")," the next transaction content to be ",(0,l.kt)("inlineCode",{parentName:"p"},"content"),"."),(0,l.kt)("admonition",{type:"tip"},(0,l.kt)("p",{parentName:"admonition"},"While ",(0,l.kt)("inlineCode",{parentName:"p"},"content")," is always a string when you read it, it is possible here to send an integer or a float for convenience.\nFor any other data structure, you should serialize it with the ",(0,l.kt)("a",{parentName:"p",href:"/build/smart-contracts/language/library#json"},"Json module")," for example.")),(0,l.kt)("h3",{id:"set_code1-transaction"},"set_code/1 ",(0,l.kt)("inlineCode",{parentName:"h3"},"[Transaction]")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-elixir"},'Contract.set_code("@version 1\\ncondition inherit: []")\n')),(0,l.kt)("p",null,"Parameters:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"code")," the code")),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Mutates")," the next transaction code to be ",(0,l.kt)("inlineCode",{parentName:"p"},"code"),"."),(0,l.kt)("admonition",{type:"tip"},(0,l.kt)("p",{parentName:"admonition"},'This example "closes" the contract, by adding an ',(0,l.kt)("inlineCode",{parentName:"p"},"condition inherit")," that doesn't accept anything. It will be impossible to create a new transaction in this chain.")),(0,l.kt)("h3",{id:"add_uco_transfer1-transaction"},"add_uco_transfer/1 ",(0,l.kt)("inlineCode",{parentName:"h3"},"[Transaction]")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-elixir"},'Contract.add_uco_transfer(to: "000012345...", amount: 1)\n')),(0,l.kt)("p",null,"Parameters:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"uco_transfer")," a map with two keys:",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"to"),": the destination address"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"amount"),": the number of UCO")))),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Mutates")," the next transaction to add the ",(0,l.kt)("inlineCode",{parentName:"p"},"uco_transfer"),"."),(0,l.kt)("h3",{id:"add_uco_transfers1-transaction"},"add_uco_transfers/1 ",(0,l.kt)("inlineCode",{parentName:"h3"},"[Transaction]")),(0,l.kt)("p",null,"Equivalent to call ",(0,l.kt)("a",{parentName:"p",href:"#add_uco_transfer1-Transaction"},"add_uco_transfer/1")," for each element of the list"),(0,l.kt)("h3",{id:"add_token_transfer1-transaction"},"add_token_transfer/1 ",(0,l.kt)("inlineCode",{parentName:"h3"},"[Transaction]")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-elixir"},'Contract.add_token_transfer(\n    to: "000012345...",\n    amount: 1.2,\n    token_address: "000023456...")\nContract.add_token_transfer(\n    to: "000012345...",\n    amount: 1.2,\n    token_id: 4,\n    token_address: "000023456...")\n')),(0,l.kt)("p",null,"Parameters:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"token_transfer")," a map with three or four keys:",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"to"),": the destination address"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"amount"),": the number of UCO"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"token_address"),": the transaction address of the token"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"[token_id]"),": an optional integer to specify which index in the list (used for the NFTs)")))),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Mutates")," the next transaction to add the ",(0,l.kt)("inlineCode",{parentName:"p"},"token_transfer"),"."),(0,l.kt)("h3",{id:"add_token_transfers1-transaction"},"add_token_transfers/1 ",(0,l.kt)("inlineCode",{parentName:"h3"},"[Transaction]")),(0,l.kt)("p",null,"Equivalent to call ",(0,l.kt)("a",{parentName:"p",href:"#add_token_transfer1-Transaction"},"add_token_transfer/1")," for each element of the list"),(0,l.kt)("h3",{id:"add_ownership1-transaction"},"add_ownership/1 ",(0,l.kt)("inlineCode",{parentName:"h3"},"[Transaction]")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-elixir"},'Contract.add_ownership(\n    secret: "ENCODED_SECRET1",\n    authorized_public_keys: ["000108A5C..."],\n    secret_key: "___")\n')),(0,l.kt)("p",null,"Parameters:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"ownership")," a map with three keys:",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"secret"),": the encoded secret"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"authorized_public_keys"),": the list of public keys that may decode the secret"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"secret_key"),": the secret key used to encode the secret")))),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Mutates")," the next transaction to add the ",(0,l.kt)("inlineCode",{parentName:"p"},"ownership"),"."),(0,l.kt)("admonition",{type:"danger"},(0,l.kt)("p",{parentName:"admonition"},"[PROBABLY REQUIRE AN EXAMPLE OR A BETTER EXPLANATION]")),(0,l.kt)("h3",{id:"add_ownerships1-transaction"},"add_ownerships/1 ",(0,l.kt)("inlineCode",{parentName:"h3"},"[Transaction]")),(0,l.kt)("p",null,"Equivalent to call ",(0,l.kt)("a",{parentName:"p",href:"#add_ownership1-Transaction"},"add_ownership/1")," for each element of the list"),(0,l.kt)("h3",{id:"add_recipient1-transaction"},"add_recipient/1 ",(0,l.kt)("inlineCode",{parentName:"h3"},"[Transaction]")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-elixir"},'Contract.add_recipient("000012345...")\n')),(0,l.kt)("p",null,"Parameters:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"address"),": a transaction address (one with a smart contract)")),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Mutates")," the next transaction to add the ",(0,l.kt)("inlineCode",{parentName:"p"},"address")," in the recipients."),(0,l.kt)("admonition",{type:"info"},(0,l.kt)("p",{parentName:"admonition"},"Recipients are used to trigger smart contracts")),(0,l.kt)("h3",{id:"add_recipients1-transaction"},"add_recipients/1 ",(0,l.kt)("inlineCode",{parentName:"h3"},"[Transaction]")),(0,l.kt)("p",null,"Equivalent to call ",(0,l.kt)("a",{parentName:"p",href:"#add_recipient1-Transaction"},"add_recipients/1")," for each element of the list"))}k.isMDXComponent=!0},8209:(e,t,n)=>{n(7294)}}]);