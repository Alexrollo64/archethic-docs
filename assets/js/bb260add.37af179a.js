"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[489],{3714:(t,e,n)=>{n.r(e),n.d(e,{assets:()=>c,contentTitle:()=>i,default:()=>p,frontMatter:()=>o,metadata:()=>s,toc:()=>l});var a=n(7462),r=(n(7294),n(3905));n(1839);const o={id:"actions",title:"Smart Contracts - Actions block",sidebar_label:"Actions",sidebar_position:3},i=void 0,s={unversionedId:"build/smart-contracts/reference/actions",id:"build/smart-contracts/reference/actions",title:"Smart Contracts - Actions block",description:"The actions block is the code executed when the associated trigger is triggered.",source:"@site/docs/build/smart-contracts/reference/actions.md",sourceDirName:"build/smart-contracts/reference",slug:"/build/smart-contracts/reference/actions",permalink:"/build/smart-contracts/reference/actions",draft:!1,tags:[],version:"current",lastUpdatedAt:1685622382,formattedLastUpdatedAt:"Jun 1, 2023",sidebarPosition:3,frontMatter:{id:"actions",title:"Smart Contracts - Actions block",sidebar_label:"Actions",sidebar_position:3},sidebar:"docs",previous:{title:"Condition",permalink:"/build/smart-contracts/reference/condition"},next:{title:"Library",permalink:"/build/smart-contracts/reference/library"}},c={},l=[{value:"Global variables",id:"global-variables",level:2},{value:"contract",id:"contract",level:4},{value:"transaction",id:"transaction",level:4},{value:"Generating the next transaction",id:"generating-the-next-transaction",level:2},{value:"Examples",id:"examples",level:2},{value:"Appendix 1: The transaction map",id:"appendix-1-the-transaction-map",level:2}],d={toc:l};function p(t){let{components:e,...n}=t;return(0,r.kt)("wrapper",(0,a.Z)({},d,n,{components:e,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"actions")," block is the code executed when the associated ",(0,r.kt)("a",{parentName:"p",href:"/build/smart-contracts/reference/triggers"},"trigger")," is triggered. "),(0,r.kt)("h2",{id:"global-variables"},"Global variables"),(0,r.kt)("p",null,"Depending on the trigger, there are different global variables accessible."),(0,r.kt)("h4",{id:"contract"},"contract"),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"contract")," variable is a map of the current contract's transaction. See ",(0,r.kt)("a",{parentName:"p",href:"#appendix-1-the-transaction-map"},"Appendix 1"),"."),(0,r.kt)("h4",{id:"transaction"},"transaction"),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"transaction")," variable is a map of the transaction that triggered the ",(0,r.kt)("inlineCode",{parentName:"p"},"actions")," block. See ",(0,r.kt)("a",{parentName:"p",href:"#appendix-1-the-transaction-map"},"Appendix 1"),". ",(0,r.kt)("strong",{parentName:"p"},"It is only available when the trigger is a transaction or an oracle"),"."),(0,r.kt)("h2",{id:"generating-the-next-transaction"},"Generating the next transaction"),(0,r.kt)("p",null,"The main goal of the action block is to generate a new transaction in the smart contract chain.",(0,r.kt)("br",{parentName:"p"}),"\n","To do so, you can use the ",(0,r.kt)("a",{parentName:"p",href:"/build/smart-contracts/reference/library#contract"},"Contract")," module that allows to set the transaction field value."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-elixir"},'# Set uco ATH in content\nactions triggered_by: oracle do\n    current_ath = String.to_number(contract.content)\n    new_price = Json.path_extract(transaction.content, "$.uco.usd")\n\n    if new_price > current_ath do\n        Contract.set_content(new_price)\n    end\nend\n')),(0,r.kt)("admonition",{type:"info"},(0,r.kt)("p",{parentName:"admonition"},"Note that there are 3 fields that are preset before executing the action code."),(0,r.kt)("ul",{parentName:"admonition"},(0,r.kt)("li",{parentName:"ul"},'type: set to "contract" by default'),(0,r.kt)("li",{parentName:"ul"},"code: set with the previous contract code"),(0,r.kt)("li",{parentName:"ul"},"ownerships: set with the previous contract ownerships")),(0,r.kt)("p",{parentName:"admonition"},"So you don't need to set the type, the code and the ownerships each time you generate a new transaction.")),(0,r.kt)("h2",{id:"examples"},"Examples"),(0,r.kt)("p",null,"An ICO (Initial Coin Offering) contract:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-elixir"},'actions triggered_by: transaction do\n    # Get the amount of UCO sent to this contract\n    amount_send = Map.get(transaction.uco_transfers, contract.address)\n\n    if amount_send > 0 do\n        # Convert UCO to the number of tokens to credit. Each UCO worth 10000 token\n        token_to_credit = amount_send * 10000\n\n        Contract.set_type("transfer")\n        Contract.add_token_transfer(to: transaction.address, token_address: contract.address, amount: token_to_credit)\n    end\nend\n')),(0,r.kt)("p",null,"An ICO contract using batching of input transactions:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-elixir"},'# Run every 10 minutes\nactions triggered_by: interval, at: "0 */10 * * *" do\n    calls = Contract.get_calls() # list of calls since last tick\n\n    if calls != [] do\n        Contract.set_type("transfer")\n    end\n\n    for call in calls do\n        # Get the amount of UCO sent to this contract\n        amount_send = Map.get(call.uco_transfers, contract.address)\n\n        if amount_send > 0 do\n            # Convert UCO to the number of tokens to credit. Each UCO worth 10000 token\n            token_to_credit = amount_send * 10000\n\n            Contract.add_token_transfer(to: call.address, token_address: contract.address, amount: token_to_credit)\n        end\n    end\nend\n')),(0,r.kt)("h2",{id:"appendix-1-the-transaction-map"},"Appendix 1: The transaction map"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"address"),"  is the transaction's address."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"type")," is the transaction's type."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"content")," is the transaction's content (it's a string that can contain anything, for example a smart contract state)"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"code")," is the transaction's code"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"timestamp")," is the transaction's validation timestamp"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"uco_transfers")," is a map of UCO transfers grouped by address of the transaction.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'["00001ab...": 1, "00001bc...": 2]\n')),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"token_transfers")," is a map of list of token transfers grouped by address of the transaction ")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'["00001ab...": \n    [\n        [amount: 1, token_address: "0000ab12..." , token_id: 1],\n        [amount: 1, token_address: "0000ab12..." , token_id: 4],\n    ]\n]\n')))}p.isMDXComponent=!0}}]);